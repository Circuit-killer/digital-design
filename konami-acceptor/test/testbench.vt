// Directive indicates that 1ns is the time period used when specifying delays
// (i.e., #10 means 10ns); 100ps is the smallest unit of time precision that
// will be simulated (100ps = .1ns; thus #.1 is meaningful, #.00001 is equivalent
// to #0)
`timescale 1ns / 100ps

module testbench ();

  reg clk;
  reg reset_;
  reg up;
  reg down;
  reg left;
  reg right;

  wire [6:0] segment_;
  wire [3:0] digit_enable_;

  // Create an instance of the circuit under test
  konamiacceptor acceptor (
    .clk(clk),
    .reset_(reset_),

    .up(up),
    .down(down),
    .left(left),
    .right(right),

    .segment_(segment_),
    .digit_enable_(digit_enable_)
  );

  // Initialize the clock signal to zero; drive reset_ active (low) for the
  // first 100ns of the simulation.
  initial begin
    clk = 1'b0;
    reset_ = 1'b0;
    up = 1'b0;
    down = 1'b0;
    left = 1'b0;
    right = 1'b0;
    #100 reset_ = 1'b1;
  end

  // Stop the simulation after 400ms; note that simulations can run indefinitely
  // (with waveforms loaded incrementally in the viewer.) Press ctrl-c to break
  // iverilog, then enter '$finish' to stop the simulation.
  initial begin
    #400000000 $finish;   // 400ms
  end

  // Toggle the clock every 31.25ns (32 MHz frequency)
  initial begin forever
	  #31.25 clk = ~clk;
	end

  initial begin
    #500;
    press_up();
    press_up();
    press_down();
    press_down();
    press_left();
    press_right();
    press_left();
    press_right();
    #100000;
    $finish;
  end

  // Produce a waveform output of this simulation
  initial begin
	  $dumpfile("waveform.vcd");
	  $dumpvars();
  end

  task press_up;
    begin
      up <= 1'b1;
      @(posedge acceptor.up_debounced);
      up <= 1'b0;
      @(negedge acceptor.up_debounced);
    end
  endtask

  task press_down;
    begin
      down <= 1'b1;
      @(posedge acceptor.down_debounced);
      down <= 1'b0;
      @(negedge acceptor.down_debounced);
    end
  endtask

  task press_left;
    begin
      left <= 1'b1;
      @(posedge acceptor.left_debounced);      
      left <= 1'b0;
      @(negedge acceptor.left_debounced);            
    end
  endtask

  task press_right;
    begin
      right <= 1'b1;
      @(posedge acceptor.right_debounced);      
      right <= 1'b0;
      @(negedge acceptor.right_debounced);      
    end
  endtask

endmodule
